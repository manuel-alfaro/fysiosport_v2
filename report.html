<!DOCTYPE html>
<html lang="sv">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rapport</title>
    <script src="https://cdn.plot.ly/plotly-2.27.1.min.js"></script>
    <link rel="stylesheet" type="text/css"
        href="https://fonts.googleapis.com/css2?family=Avenir:wght@400&family=Futura:wght@400&display=swap">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        :root {
            --app-primary-color: #285484;
            --app-secondary-color: rgb(112, 188, 252);
            --app-tertiary-color: #121630;
            --app-text-on-primary: #ffffff;
            --light-gray: #f8f9fa;
            --box-background-color: #f0f2f5;
            --medium-gray: #dee2e6;
            --dark-gray: #495057;
            --text-color: #212529;
            --success-color: #2a9d8f;
            --danger-color: #e63946;
            --white: #ffffff;
            --border-radius: 4px;

            --ho-color: #193c64;
            --va-color: #c8a84f;

            --base-font-size-css: 16px;
            --normal-font-weight: 400;
            --semibold-font-weight: 400;
            --bold-font-weight: 700;
        }

        body {
            font-family: 'Avenir', sans-serif;
            background-color: var(--white);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            width: 100%;
            box-sizing: border-box;
            line-height: 1.6;
            font-weight: var(--normal-font-weight);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .page {
            overflow: hidden;
        }

        .page-break {
            page-break-after: always;
        }

        .app-main-content {
            padding: 5mm 20mm !important;
            height: auto !important;
            overflow: visible !important;
            box-shadow: none !important;
            border: none !important;
        }

        .content-container {
            max-width: 100% !important;
            margin: 0 auto;
        }

        .report-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10mm 20mm 0 20mm;
            margin-bottom: 15px;
        }

        .report-header img {
            max-height: 35px;
            width: auto;
        }

        h3.position-title,
        h3.normative-title {
            color: var(--dark-gray);
            margin-bottom: 0.3em;
            text-transform: uppercase;
            text-align: center;
        }

        .info-box {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px 30px;
            background-color: var(--white);
            border: 1px solid var(--medium-gray);
            padding: 12px 20px;
            margin-bottom: 25px;
            border-radius: var(--border-radius);
            font-size: 13px;
        }

        .info-box div {
            display: flex;
            justify-content: space-between;
            padding-bottom: 4px;
        }

        .info-box strong {
            color: var(--app-primary-color);
            margin-right: 10px;
            font-weight: var(--semibold-font-weight);
        }

        .explanation-box-small {
            display: flex !important;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
            background-color: var(--box-background-color);
            border: none;
            border-left: 4px solid var(--app-primary-color);
            padding: 10px 15px;
            margin-top: 10px;
            border-radius: var(--border-radius);
            color: var(--dark-gray);
            page-break-inside: avoid;
            font-size: calc(12px * var(--scale-factor, 1));
            min-height: 50px;
            box-sizing: border-box;
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
        }

        .explanation-box-small i {
            font-size: 1.4em;
            color: var(--app-primary-color);
        }

        .explanation-box-small p {
            margin: 0;
        }

        .percentage-display {
            font-weight: var(--bold-font-weight);
            font-size: 1.1em;
        }

        .percentage-display.green {
            color: var(--success-color);
        }

        .percentage-display.red {
            color: var(--danger-color);
        }


        .position-box,
        .normative-box {
            border: none !important;
            padding: 10px 20px 15px 20px !important;
            border-radius: var(--border-radius);
            background-color: var(--box-background-color) !important;
            box-shadow: none !important;
            margin-bottom: 0;
            display: flex !important;
            flex-direction: column !important;
            height: 200px !important;
            min-height: 200px !important;
            position: relative;
            overflow: hidden !important;
            width: 100% !important;
            box-sizing: border-box !important;
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
        }

        .js-plotly-plot {
            flex-grow: 1 !important;
            position: relative;
            z-index: 1;
            width: 100% !important;
            height: 100% !important;
        }

        .js-plotly-plot .plotly>div,
        .js-plotly-plot .plotly>div>svg {
            max-width: 100%;
            height: auto !important;
        }

        .plotly .scatterlayer .trace.fill {
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
        }

        .plotly .annotation text {
            font-weight: normal !important;
        }

        .plotly .gtitle {
            fill: black !important;
            font-weight: normal !important;
        }

        .plotly .modebar {
            display: none !important;
        }

        .js-plotly-plot .plotly svg {
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
        }

        .js-plotly-plot .plotly text {
            pointer-events: auto !important;
        }

        .position-row {
            display: flex !important;
            flex-wrap: wrap !important;
            gap: 20px !important;
            margin-bottom: 20px;
            padding-bottom: 3px;
            align-items: stretch;
            page-break-inside: avoid !important;
            width: 100% !important;
            box-sizing: border-box !important;
        }

        .graph-column {
            flex: 0 0 calc(50% - 10px) !important;
            min-width: 0 !important;
            display: flex;
            flex-direction: column;
            page-break-inside: avoid !important;
        }

        .text-box {
            background-color: var(--box-background-color);
            padding: 15px 20px;
            border-radius: var(--border-radius);
            height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            box-sizing: border-box;
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
        }

        .text-box .text-content {
            color: var(--dark-gray);
            font-size: calc(13px * var(--scale-factor, 1));
            flex-grow: 1;
        }

        .text-box h3.position-title {
            font-size: calc(18.4px * var(--scale-factor, 1));
        }

        .text-box .text-content p {
            margin: 5px 0;
            line-height: 1.5;
        }

        .text-box .text-content b {
            font-size: 1.1em;
        }

        .graph-overlay-image {
            position: absolute;
            top: 55px;
            /* Moved up */
            left: 80%;
            transform: translateX(-50%);
            width: 80px;
            height: auto;
            pointer-events: none;
            z-index: 2;
        }

        .graph-overlay-text {
            position: absolute;
            bottom: 30px;
            /* Moved up */
            left: 80%;
            transform: translateX(-50%);
            width: 100px;
            font-size: 10px;
            color: var(--dark-gray);
            text-align: center;
            pointer-events: none;
            z-index: 2;
            line-height: 1.2;
        }

        #donut-container {
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 100%;
            flex-grow: 1;
        }

        .donut-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            height: 100%;
            justify-content: center;
        }

        .donut-wrapper .js-plotly-plot {
            width: 90px !important;
            height: 90px !important;
        }

        .donut-label {
            margin-top: 8px;
            font-size: 11px;
            color: var(--dark-gray);
            text-align: center;
            font-weight: var(--semibold-font-weight);
        }

        .no-data-placeholder {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: var(--medium-gray);
            text-align: center;
            flex-grow: 1;
        }

        .no-data-placeholder i {
            font-size: 3em;
            margin-bottom: 15px;
        }

        .hidden {
            display: none !important;
        }


        @media print {
            @page {
                margin: 0;
                size: auto;
            }

            body {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }

            .page {
                box-shadow: none !important;
                border: none !important;
                margin: 0;
                padding: 0;
            }
        }
    </style>
</head>

<body>
    <div id="page-1" class="page">
        <header class="report-header">

            <img src="https://storage.googleapis.com/intro_alphatek/Kopi%2Bav%2BLogo%2BNegative%2Bnarrow.webp"
                alt="Alphatek Logo" class="logo-right">
        </header>
        <main class="app-main-content">
            <div class="content-container">
                <div id="report-content-page1">
                    <div class="info-box">
                        <div><strong>NAMN:</strong> <span id="p1-name"></span></div>
                        <div><strong>DATUM:</strong> <span id="p1-date"></span></div>
                        <div><strong>SPORT/POSITION:</strong> <span id="p1-sport"></span></div>
                        <div><strong>SKAPAD AV:</strong> <span id="p1-createdBy"></span></div>
                    </div>

                    <!-- This container will be populated dynamically -->

                </div>
            </div>
        </main>
    </div>

    <div id="page-2" class="page">
        <header class="report-header">

            <img src="https://storage.googleapis.com/intro_alphatek/Kopi%2Bav%2BLogo%2BNegative%2Bnarrow.webp"
                alt="Alphatek Logo" class="logo-right">
        </header>
        <main class="app-main-content">
            <div class="content-container">
                <div id="report-content-page2">
                    <div class="info-box">
                        <div><strong>NAMN:</strong> <span id="p2-name"></span></div>
                        <div><strong>DATUM:</strong> <span id="p2-date"></span></div>
                        <div><strong>SPORT/POSITION:</strong> <span id="p2-sport"></span></div>
                        <div><strong>SKAPAD AV:</strong> <span id="p2-createdBy"></span></div>
                    </div>

                    <!-- This container will be populated dynamically -->

                </div>
            </div>
        </main>
    </div>

    <div id="page-3" class="page">
        <header class="report-header">

            <img src="https://storage.googleapis.com/intro_alphatek/Kopi%2Bav%2BLogo%2BNegative%2Bnarrow.webp"
                alt="Alphatek Logo" class="logo-right">
        </header>
        <main class="app-main-content">
            <div class="content-container">
                <div id="report-content-page3">
                    <div class="info-box">
                        <div><strong>NAMN:</strong> <span id="p3-name"></span></div>
                        <div><strong>DATUM:</strong> <span id="p3-date"></span></div>
                        <div><strong>SPORT/POSITION:</strong> <span id="p3-sport"></span></div>
                        <div><strong>SKAPAD AV:</strong> <span id="p3-createdBy"></span></div>
                    </div>

                    <!-- This container will be populated dynamically -->

                </div>
            </div>
        </main>
    </div>

    <!-- Template elements that will be cloned and moved -->
    <div id="templates" class="hidden">
        <div id="col-balance" class="graph-column">
            <div id="p1-position-box-I" class="position-box">
                <h3 class="position-title"></h3>
                <div id="p1-bar-chart-I" class="js-plotly-plot"></div>
            </div>
            <div id="p1-balance-comment-box" class="explanation-box-small">
                <p class="comment-text"></p>
            </div>
        </div>
        <div id="col-cmj" class="graph-column">
            <div id="p1-normative-chart-container-I" class="normative-box">
                <h3 class="normative-title"></h3>
                <div id="p1-bar-chart-I-copy" class="js-plotly-plot"></div>
            </div>
            <div id="p1-cmj-comment-box" class="explanation-box-small">
                <p class="comment-text"></p>
            </div>
        </div>
        <div id="col-tia" class="graph-column">
            <div id="p1-position-box-Y" class="position-box">
                <h3 class="position-title"></h3>
                <div id="p1-bar-chart-Y" class="js-plotly-plot"></div>
            </div>
            <div id="p1-tia-comment-box" class="explanation-box-small">
                <p class="comment-text"></p>
            </div>
        </div>
        <div id="col-sidehop" class="graph-column">
            <div id="p1-normative-chart-container-Y" class="normative-box">
                <h3 class="normative-title"></h3>
                <div id="p1-bar-chart-Y-copy" class="js-plotly-plot"></div>
            </div>
            <div id="p1-sidehop-comment-box" class="explanation-box-small">
                <p class="comment-text"></p>
            </div>
        </div>
        <div id="col-squat" class="graph-column">
            <div id="p1-position-box-T" class="position-box">
                <h3 class="position-title"></h3>
                <div id="donut-container">
                    <div class="donut-wrapper">
                        <div id="donut-chart-1" class="js-plotly-plot"></div>
                        <p class="donut-label">Försök 1</p>
                    </div>
                    <div class="donut-wrapper">
                        <div id="donut-chart-2" class="js-plotly-plot"></div>
                        <p class="donut-label">Försök 2</p>
                    </div>
                    <div class="donut-wrapper">
                        <div id="donut-chart-3" class="js-plotly-plot"></div>
                        <p class="donut-label">Försök 3</p>
                    </div>
                </div>
            </div>
            <div id="p1-squat-comment-box" class="explanation-box-small">
                <p class="comment-text"></p>
            </div>
        </div>
        <div id="col-repeated" class="graph-column">
            <div id="p1-normative-chart-container-T" class="normative-box">
                <h3 class="normative-title"></h3>
                <div id="p1-bar-chart-T-copy" class="js-plotly-plot"></div>
            </div>
            <div id="p1-repeated-comment-box" class="explanation-box-small">
                <p class="comment-text"></p>
            </div>
        </div>
        <div id="col-cmj2ben" class="graph-column">
            <div id="p1-cmj2ben-position-box" class="position-box">
                <h3 class="position-title"></h3>
                <div id="donut-container">
                    <div class="donut-wrapper">
                        <div id="cmj2ben-donut-1" class="js-plotly-plot"></div>
                        <p class="donut-label">Försök 1</p>
                    </div>
                    <div class="donut-wrapper">
                        <div id="cmj2ben-donut-2" class="js-plotly-plot"></div>
                        <p class="donut-label">Försök 2</p>
                    </div>
                    <div class="donut-wrapper">
                        <div id="cmj2ben-donut-3" class="js-plotly-plot"></div>
                        <p class="donut-label">Försök 3</p>
                    </div>
                </div>
            </div>
            <div id="p1-cmj2ben-comment-box" class="explanation-box-small">
                <p class="comment-text"></p>
            </div>
        </div>
        <div id="col-hipthrust" class="graph-column">
            <div id="p2-position-box-I" class="position-box">
                <h3 class="position-title"></h3>
                <div id="p2-bar-chart-I" class="js-plotly-plot"></div>
                <img id="overlay-image-I" src="" class="graph-overlay-image" alt="Animal">
                <div id="overlay-text-I" class="graph-overlay-text"></div>
            </div>
            <div id="p2-hipthrust-comment-box" class="explanation-box-small">
                <p class="comment-text"></p>
            </div>
        </div>
        <div id="col-quads" class="graph-column">
            <div id="p2-normative-chart-container-I" class="normative-box">
                <h3 class="normative-title"></h3>
                <div id="p2-bar-chart-I-copy" class="js-plotly-plot"></div>
            </div>
            <div id="p2-quads-comment-box" class="explanation-box-small">
                <p class="comment-text"></p>
            </div>
        </div>
        <div id="col-staticsquat-handdrag" class="graph-column">
            <div id="p2-position-box-handdrag" class="position-box">
                <h3 class="position-title"></h3>
                <div id="p2-bar-chart-handdrag" class="js-plotly-plot"></div>
                <img id="overlay-image-handdrag" src="" class="graph-overlay-image" alt="Animal">
                <div id="overlay-text-handdrag" class="graph-overlay-text"></div>
            </div>
            <div id="p2-staticsquat-handdrag-comment-box" class="explanation-box-small">
                <p class="comment-text"></p>
            </div>
        </div>
        <div id="col-staticsquat-hoftrem" class="graph-column">
            <div id="p2-position-box-hoftrem" class="position-box">
                <h3 class="position-title"></h3>
                <div id="p2-bar-chart-hoftrem" class="js-plotly-plot"></div>
                <img id="overlay-image-hoftrem" src="" class="graph-overlay-image" alt="Animal">
                <div id="overlay-text-hoftrem" class="graph-overlay-text"></div>
            </div>
            <div id="p2-staticsquat-hoftrem-comment-box" class="explanation-box-small">
                <p class="comment-text"></p>
            </div>
        </div>
        <div id="col-hamstring" class="graph-column">
            <div id="p2-normative-chart-container-Y" class="normative-box">
                <h3 class="normative-title"></h3>
                <div id="p2-bar-chart-Y-copy" class="js-plotly-plot"></div>
            </div>
            <div id="p2-hamstring-comment-box" class="explanation-box-small">
                <p class="comment-text"></p>
            </div>
        </div>
        <div id="col-nordic-hamstring" class="graph-column">
            <div id="p2-nordic-hamstring-position-box" class="position-box">
                <h3 class="position-title"></h3>
                <div id="donut-container">
                    <div class="donut-wrapper">
                        <div id="nordic-hamstring-donut-1" class="js-plotly-plot"></div>
                        <p class="donut-label">Försök 1</p>
                    </div>
                    <div class="donut-wrapper">
                        <div id="nordic-hamstring-donut-2" class="js-plotly-plot"></div>
                        <p class="donut-label">Försök 2</p>
                    </div>
                    <div class="donut-wrapper">
                        <div id="nordic-hamstring-donut-3" class="js-plotly-plot"></div>
                        <p class="donut-label">Försök 3</p>
                    </div>
                </div>
            </div>
            <div id="p2-nordic-hamstring-comment-box" class="explanation-box-small">
                <p class="comment-text"></p>
            </div>
        </div>
        <div id="col-srp" class="graph-column text-box">
            <h3 class="position-title">STATIC ROW PULL</h3>
            <div class="text-content" id="manual-srp"></div>
        </div>
        <div id="col-spts" class="graph-column text-box">
            <h3 class="position-title">SQUAT POWER TO SPEED</h3>
            <div class="text-content" id="manual-spts"></div>
        </div>
        <div id="col-mpu" class="graph-column text-box">
            <h3 class="position-title">MAX PRESS PUSH UP</h3>
            <div class="text-content" id="manual-mpu"></div>
        </div>
        <div id="col-bpc" class="graph-column text-box">
            <h3 class="position-title">BLAZE POD CHALLENGE</h3>
            <div class="text-content" id="manual-bpc"></div>
        </div>
        <!-- Generic Custom Test Template -->
        <div id="col-custom" class="graph-column">
            <div class="position-box">
                <h3 class="position-title">CUSTOM TEST</h3>
                <div class="js-plotly-plot"></div>
            </div>
            <div class="explanation-box-small">
                <p class="comment-text"></p>
            </div>
        </div>
    </div>


    <script>
        const plotlyConfig = { responsive: true, displaylogo: false, modeBarButtonsToRemove: ['sendDataToCloud', 'lasso2d', 'select2d', 'autoScale2d', 'hoverClosestCartesian', 'hoverCompareCartesian', 'toggleSpikelines'] };
        const globalScaleFactor = 0.65;

        function hexToRgba(hex, alpha) { hex = hex.replace('#', ''); const r = parseInt(hex.substring(0, 2), 16); const g = parseInt(hex.substring(2, 4), 16); const b = parseInt(hex.substring(4, 6), 16); return `rgba(${r}, ${g}, ${b}, ${alpha})`; }

        function scaleHtmlFontSizes(scaleFactor) {
            document.documentElement.style.setProperty('--scale-factor', scaleFactor);
            const originalSizes = { body: 16, h1: 32, h2: 24, h3Base: 18.4, explanationBoxBase: 14.4 };
            const newBodyFontSize = Math.round(originalSizes.body * scaleFactor);
            document.body.style.fontSize = newBodyFontSize + 'px';

            document.querySelectorAll('h3.position-title, h3.normative-title').forEach(el => { el.style.fontSize = Math.round(originalSizes.h3Base * scaleFactor) + 'px'; });
            document.querySelectorAll('.explanation-box-small').forEach(el => { el.style.fontSize = Math.round(originalSizes.explanationBoxBase * scaleFactor) + 'px'; });
        }

        // --- PAGE 2 ANIMAL LOGIC ---
        function getAnimalForWeight(weight) {
            const baseUrl = "https://storage.googleapis.com/intro_alphatek/animals/";
            if (weight <= 66.2) return { name: "Koala", url: baseUrl + "Koala.png" };
            if (weight <= 99.5) return { name: "Dog", url: baseUrl + "Dog.png" };
            if (weight <= 132.8) return { name: "Kangaroo", url: baseUrl + "Kangaroo.png" };
            if (weight <= 166.2) return { name: "Gazelle", url: baseUrl + "Gazelle.png" };
            if (weight <= 199.5) return { name: "Jaguar", url: baseUrl + "Jaguar.png" };
            if (weight <= 232.8) return { name: "Panda", url: baseUrl + "Panda.png" };
            if (weight <= 266.2) return { name: "Wild Hog", url: baseUrl + "Wild%20Hog.png" };
            if (weight <= 299.5) return { name: "Lion", url: baseUrl + "Lion.png" };
            if (weight <= 332.8) return { name: "Tiger", url: baseUrl + "Tiger.png" };
            if (weight <= 366.2) return { name: "Gorilla", url: baseUrl + "Gorilla.png" };
            if (weight <= 399.5) return { name: "Anaconda", url: baseUrl + "Anaconda(1).png" };
            if (weight <= 432.8) return { name: "Alligator", url: baseUrl + "Alligator.png" };
            if (weight <= 466.2) return { name: "Grizzly", url: baseUrl + "Grizzly.png" };
            if (weight <= 499.5) return { name: "Polar Bear", url: baseUrl + "Polar%20Bear.png" };
            return { name: "The Beast", url: baseUrl + "the_beast.png" };
        }

        function updateAnimalOverlay(weight, imageElement, textElement) {
            const animal = getAnimalForWeight(weight);
            imageElement.src = animal.url;
            textElement.innerHTML = `Sammanlagd kraft: ${weight.toFixed(1)} kg<br>Du är en ${animal.name}!`;
        }

        // --- CHART CREATION FUNCTIONS ---
        function createDualAxisBarChart(data, config) {
            const vaColorHex = getComputedStyle(document.documentElement).getPropertyValue('--va-color').trim();
            const hoColorHex = getComputedStyle(document.documentElement).getPropertyValue('--ho-color').trim();
            const leftColorRgba = hexToRgba(vaColorHex, 0.8);
            const rightColorRgba = hexToRgba(hoColorHex, 0.8);
            const darkGrayColor = getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim();
            const whiteColor = getComputedStyle(document.documentElement).getPropertyValue('--white').trim();

            const { leftVal1, rightVal1, leftVal2, rightVal2 } = data;
            const { metricNames, y1Title, y2Title, y1Decimals, y2Decimals } = config;

            const maxY1 = Math.max(leftVal1, rightVal1, 0.1) * 1.25;
            const maxY2 = Math.max(leftVal2, rightVal2, 0.1) * 1.25;
            const barTextFontSize = Math.round(18 * globalScaleFactor);

            const fig = {
                data: [
                    { type: 'bar', name: 'VÄ', x: [metricNames[0]], y: [leftVal1], marker: { color: leftColorRgba }, text: [leftVal1.toFixed(y1Decimals)], textposition: 'inside', insidetextanchor: 'middle', textfont: { color: whiteColor, size: barTextFontSize }, hoverinfo: 'name+x+y', yaxis: 'y' },
                    { type: 'bar', name: 'HÖ', x: [metricNames[0]], y: [rightVal1], marker: { color: rightColorRgba }, text: [rightVal1.toFixed(y1Decimals)], textposition: 'inside', insidetextanchor: 'middle', textfont: { color: whiteColor, size: barTextFontSize }, hoverinfo: 'name+x+y', yaxis: 'y' },
                    { type: 'bar', name: 'VÄ', x: [metricNames[1]], y: [leftVal2], marker: { color: leftColorRgba }, text: [leftVal2.toFixed(y2Decimals)], textposition: 'inside', insidetextanchor: 'middle', textfont: { color: whiteColor, size: barTextFontSize }, hoverinfo: 'name+x+y', yaxis: 'y2', showlegend: false },
                    { type: 'bar', name: 'HÖ', x: [metricNames[1]], y: [rightVal2], marker: { color: rightColorRgba }, text: [rightVal2.toFixed(y2Decimals)], textposition: 'inside', insidetextanchor: 'middle', textfont: { color: whiteColor, size: barTextFontSize }, hoverinfo: 'name+x+y', yaxis: 'y2', showlegend: false },
                ],
                layout: {
                    height: 200, barmode: 'group',
                    font: { color: darkGrayColor, family: 'Avenir, sans-serif', size: Math.round(14 * globalScaleFactor), weight: 400 },
                    yaxis: { title: y1Title, titlefont: { size: Math.round(16 * globalScaleFactor) }, tickfont: { size: Math.round(14 * globalScaleFactor) }, range: [0, maxY1], showgrid: false, zeroline: false },
                    yaxis2: { title: y2Title, titlefont: { size: Math.round(16 * globalScaleFactor) }, tickfont: { size: Math.round(14 * globalScaleFactor) }, overlaying: 'y', side: 'right', showgrid: false, zeroline: false, showline: false, range: [0, maxY2] },
                    xaxis: { showgrid: false, zeroline: false, showline: false, tickfont: { size: Math.round(14 * globalScaleFactor) }, automargin: true, fixedrange: true, categoryorder: 'array', categoryarray: metricNames },
                    paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
                    legend: { orientation: "h", yanchor: "bottom", y: 1.02, xanchor: "center", x: 0.5, font: { size: Math.round(14 * globalScaleFactor) } },
                    margin: { l: 50, r: 65, b: 75, t: 35, pad: 5 },
                    width: 285, bargap: 0.4, bargroupgap: 0.1
                }
            };
            return fig;
        }

        function createGroupedBarChart(data, config) {
            const hoColorHex = getComputedStyle(document.documentElement).getPropertyValue('--ho-color').trim();
            const vaColorHex = getComputedStyle(document.documentElement).getPropertyValue('--va-color').trim();
            const hoColorRgba = hexToRgba(hoColorHex, 0.8);
            const vaColorRgba = hexToRgba(vaColorHex, 0.8);
            const darkGrayColor = getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim();
            const whiteColor = getComputedStyle(document.documentElement).getPropertyValue('--white').trim();

            const { labels, vaValues, hoValues } = data;
            const { yTitle } = config;
            const maxYValue = Math.max(...vaValues, ...hoValues, 10) + 10;
            const barTextFontSize = Math.round(18 * globalScaleFactor);

            const fig = {
                data: [
                    { type: 'bar', name: 'VÄ', x: labels, y: vaValues, marker: { color: vaColorRgba }, text: vaValues.map(String), textposition: 'inside', insidetextanchor: 'middle', textfont: { color: whiteColor, size: barTextFontSize }, hoverinfo: 'name', hovertemplate: 'VÄ: %{y} cm<extra></extra>' },
                    { type: 'bar', name: 'HÖ', x: labels, y: hoValues, marker: { color: hoColorRgba }, text: hoValues.map(String), textposition: 'inside', insidetextanchor: 'middle', textfont: { color: whiteColor, size: barTextFontSize }, hoverinfo: 'name', hovertemplate: 'HÖ: %{y} cm<extra></extra>' }
                ],
                layout: {
                    height: 200, barmode: 'group',
                    font: { color: darkGrayColor, family: 'Avenir', size: Math.round(14 * globalScaleFactor), weight: 400 },
                    yaxis: { title: yTitle, titlefont: { size: Math.round(16 * globalScaleFactor) }, tickfont: { size: Math.round(14 * globalScaleFactor) }, range: [0, maxYValue], showgrid: false, zeroline: false },
                    xaxis: { showgrid: false, zeroline: false, showline: false, tickfont: { size: Math.round(14 * globalScaleFactor) }, automargin: true, fixedrange: true },
                    paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
                    legend: { orientation: "h", yanchor: "bottom", y: 1.02, xanchor: "center", x: 0.5, font: { size: Math.round(14 * globalScaleFactor) } },
                    margin: { l: 50, r: 20, b: 75, t: 35, pad: 5 },
                    width: 285, bargroupgap: 0.1
                }
            };
            return fig;
        }

        // New function for 3-bar charts (Right, Left, Both)
        function createThreeBarChart(data, config) {
            const hoColorHex = getComputedStyle(document.documentElement).getPropertyValue('--ho-color').trim();
            const vaColorHex = getComputedStyle(document.documentElement).getPropertyValue('--va-color').trim();
            const bothColor = '#1e88e5'; // A neutral blue for "Båda"
            const hoColorRgba = hexToRgba(hoColorHex, 0.8);
            const vaColorRgba = hexToRgba(vaColorHex, 0.8);
            const bothColorRgba = hexToRgba(bothColor, 0.8);
            const darkGrayColor = getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim();
            const whiteColor = getComputedStyle(document.documentElement).getPropertyValue('--white').trim();

            const { rightVal, leftVal, bothVal } = data;
            const { yAxisTitle, decimals } = config;
            const maxYValue = Math.max(rightVal, leftVal, bothVal, 10) * 1.25;
            const barTextFontSize = Math.round(18 * globalScaleFactor);
            const labels = ['VÄ', 'HÖ', 'TVÅ BEN'];
            const values = [leftVal, rightVal, bothVal];
            const colors = [vaColorRgba, hoColorRgba, bothColorRgba];

            const fig = {
                data: [{
                    type: 'bar',
                    x: labels,
                    y: values,
                    marker: { color: colors },
                    text: values.map(val => val.toFixed(decimals)),
                    textposition: 'inside',
                    insidetextanchor: 'middle',
                    textfont: { color: whiteColor, size: barTextFontSize, angle: 0 },
                    hoverinfo: 'x+y'
                }],
                layout: {
                    height: 200,
                    font: { color: darkGrayColor, family: 'Avenir', size: Math.round(14 * globalScaleFactor), weight: 400 },
                    yaxis: { title: yAxisTitle, titlefont: { size: Math.round(16 * globalScaleFactor) }, tickfont: { size: Math.round(14 * globalScaleFactor) }, range: [0, maxYValue], showgrid: true, zeroline: false },
                    xaxis: { showgrid: false, zeroline: false, showline: false, tickfont: { size: Math.round(14 * globalScaleFactor) }, automargin: true, fixedrange: true },
                    paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
                    showlegend: false,
                    margin: { l: 50, r: 20, b: 75, t: 35, pad: 5 },
                    width: 285, bargap: 0.4
                }
            };
            return fig;
        }

        function createSingleMetricBarChart(data, config) {
            const hoColorHex = getComputedStyle(document.documentElement).getPropertyValue('--ho-color').trim();
            const vaColorHex = getComputedStyle(document.documentElement).getPropertyValue('--va-color').trim();
            const hoColorRgba = hexToRgba(hoColorHex, 0.8);
            const vaColorRgba = hexToRgba(vaColorHex, 0.8);
            const darkGrayColor = getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim();
            const whiteColor = getComputedStyle(document.documentElement).getPropertyValue('--white').trim();

            const { leftVal, rightVal } = data;
            const { yAxisTitle, metricName, decimals } = config;
            const maxYValue = Math.max(leftVal, rightVal, 10) * 1.25;
            const barTextFontSize = Math.round(18 * globalScaleFactor);

            const fig = {
                data: [
                    { type: 'bar', name: 'VÄ', x: [' ', metricName, '  '], y: [null, leftVal, null], marker: { color: vaColorRgba }, text: [null, leftVal.toFixed(decimals), null], textposition: 'inside', insidetextanchor: 'middle', textfont: { color: whiteColor, size: barTextFontSize }, hoverinfo: 'name', hovertemplate: 'VÄ: %{y}<extra></extra>' },
                    { type: 'bar', name: 'HÖ', x: [' ', metricName, '  '], y: [null, rightVal, null], marker: { color: hoColorRgba }, text: [null, rightVal.toFixed(decimals), null], textposition: 'inside', insidetextanchor: 'middle', textfont: { color: whiteColor, size: barTextFontSize }, hoverinfo: 'name', hovertemplate: 'HÖ: %{y}<extra></extra>' }
                ],
                layout: {
                    height: 200, barmode: 'group',
                    font: { color: darkGrayColor, family: 'Avenir', size: Math.round(14 * globalScaleFactor), weight: 400 },
                    yaxis: { title: yAxisTitle, titlefont: { size: Math.round(16 * globalScaleFactor) }, tickfont: { size: Math.round(14 * globalScaleFactor) }, range: [0, maxYValue], showgrid: true, zeroline: false },
                    xaxis: { showgrid: false, zeroline: false, showline: false, tickfont: { size: Math.round(14 * globalScaleFactor) }, automargin: true, fixedrange: true },
                    paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
                    legend: { orientation: "h", yanchor: "bottom", y: 1.02, xanchor: "center", x: 0.5, font: { size: Math.round(14 * globalScaleFactor) } },
                    margin: { l: 50, r: 20, b: 75, t: 35, pad: 5 },
                    width: 285, bargroupgap: 0.1
                }
            };
            return fig;
        }

        function createSingleDonutChart(value) {
            const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--app-primary-color').trim();
            const primaryColorRgba = hexToRgba(primaryColor, 0.8);
            const emptyColorRgba = 'rgba(222, 226, 230, 0.8)';
            const darkGrayColor = getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim();

            const barWidth = 360 * (value / 100);

            const data = [
                { type: "barpolar", r: [100], theta: [0], width: [360], marker: { color: emptyColorRgba }, hoverinfo: "none", layer: 'below' },
                { type: "barpolar", r: [100], theta: [barWidth / 2], width: [barWidth], marker: { color: primaryColorRgba }, hoverinfo: "none" }
            ];

            const layout = {
                showlegend: false,
                paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
                margin: { t: 5, b: 5, l: 5, r: 5 },
                polar: { hole: 0.7, barmode: 'overlay', radialaxis: { visible: false, range: [0, 100] }, angularaxis: { rotation: 90, direction: "clockwise", visible: false } },
                annotations: [{ font: { size: Math.round(20 * globalScaleFactor), color: darkGrayColor, weight: 'bold' }, showarrow: false, text: `${value}`, x: 0.5, y: 0.5, xanchor: 'center', yanchor: 'middle' }]
            };
            return { data, layout };
        }

        function createBilateralDualAxisChart(data, config) {
            const primaryColorHex = getComputedStyle(document.documentElement).getPropertyValue('--app-primary-color').trim();
            const primaryColorRgba = hexToRgba(primaryColorHex, 0.8);
            const darkGrayColor = getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim();
            const whiteColor = getComputedStyle(document.documentElement).getPropertyValue('--white').trim();

            const { val1, val2 } = data;
            const { metricNames, y1Title, y2Title } = config;

            const maxY1 = val1 * 1.25;
            const maxY2 = val2 * 1.25;
            const barTextFontSize = Math.round(18 * globalScaleFactor);

            const fig = {
                data: [
                    { type: 'bar', name: metricNames[0], x: [metricNames[0]], y: [val1], marker: { color: primaryColorRgba }, text: [val1.toFixed(1)], textposition: 'inside', insidetextanchor: 'middle', textfont: { color: whiteColor, size: barTextFontSize }, hoverinfo: 'name+y', yaxis: 'y' },
                    { type: 'bar', name: metricNames[1], x: [metricNames[1]], y: [val2], marker: { color: primaryColorRgba }, text: [val2.toFixed(2)], textposition: 'inside', insidetextanchor: 'middle', textfont: { color: whiteColor, size: barTextFontSize }, hoverinfo: 'name+y', yaxis: 'y2' },
                ],
                layout: {
                    height: 200, barmode: 'group', showlegend: false,
                    font: { color: darkGrayColor, family: 'Avenir', size: Math.round(14 * globalScaleFactor), weight: 400 },
                    yaxis: { title: y1Title, titlefont: { size: Math.round(16 * globalScaleFactor) }, tickfont: { size: Math.round(14 * globalScaleFactor) }, range: [0, maxY1], showgrid: false, zeroline: false },
                    yaxis2: { title: y2Title, titlefont: { size: Math.round(16 * globalScaleFactor) }, tickfont: { size: Math.round(14 * globalScaleFactor) }, overlaying: 'y', side: 'right', showgrid: false, zeroline: false, showline: false, range: [0, maxY2] },
                    xaxis: { showgrid: false, zeroline: false, showline: false, tickfont: { size: Math.round(14 * globalScaleFactor) }, automargin: true, fixedrange: true, categoryorder: 'array', categoryarray: metricNames },
                    paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
                    margin: { l: 50, r: 65, b: 75, t: 35, pad: 5 },
                    width: 285, bargap: 0.5,
                }
            };
            return fig;
        }

        function createPage2CustomBarChart(chartData, config = {}) {
            const vaColorHex = getComputedStyle(document.documentElement).getPropertyValue('--va-color').trim();
            const hoColorHex = getComputedStyle(document.documentElement).getPropertyValue('--ho-color').trim();
            const vaColorRgba = hexToRgba(vaColorHex, 0.8);
            const hoColorRgba = hexToRgba(hoColorHex, 0.8);
            const darkGrayColor = getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim();
            const whiteColor = getComputedStyle(document.documentElement).getPropertyValue('--white').trim();

            const { leftVal1 = 0, rightVal1 = 0 } = chartData;
            const { yAxisTitle = 'Value', metricNames = ['Gj. hopphøyde', 'GCT'], decimals = 1 } = config;

            const leftTexts = [leftVal1.toFixed(decimals), ''];
            const rightTexts = [rightVal1.toFixed(decimals), ''];

            const maxY1 = Math.max(leftVal1, rightVal1, 0.1) * 1.25;
            const barTextFontSize = Math.round(18 * globalScaleFactor);

            const data = [
                { type: 'bar', name: 'VÄ', x: [metricNames[0]], y: [leftVal1], marker: { color: vaColorRgba }, text: [leftTexts[0]], textposition: 'inside', insidetextanchor: 'middle', textfont: { color: whiteColor, size: barTextFontSize, angle: 0 }, hoverinfo: 'name+y', yaxis: 'y' },
                { type: 'bar', name: 'HÖ', x: [metricNames[0]], y: [rightVal1], marker: { color: hoColorRgba }, text: [rightTexts[0]], textposition: 'inside', insidetextanchor: 'middle', textfont: { color: whiteColor, size: barTextFontSize, angle: 0 }, hoverinfo: 'name+y', yaxis: 'y' },
                { type: 'bar', name: 'VÄ', x: [metricNames[1]], y: [0], marker: { color: 'rgba(0,0,0,0)' }, text: [''], hoverinfo: 'none', yaxis: 'y2', showlegend: false },
                { type: 'bar', name: 'HÖ', x: [metricNames[1]], y: [0], marker: { color: 'rgba(0,0,0,0)' }, text: [''], hoverinfo: 'none', yaxis: 'y2', showlegend: false }
            ];

            const fig = {
                data: data,
                layout: {
                    height: 200, barmode: 'group',
                    font: { color: darkGrayColor, family: 'Avenir', size: Math.round(14 * globalScaleFactor), weight: 400 },
                    yaxis: { title: yAxisTitle, titlefont: { size: Math.round(16 * globalScaleFactor) }, tickfont: { size: Math.round(14 * globalScaleFactor) }, range: [0, maxY1], showgrid: false, zeroline: false },
                    yaxis2: { visible: false, range: [0, 1] },
                    xaxis: {
                        showgrid: false, zeroline: false, showline: false, showticklabels: true,
                        tickangle: 0, tickfont: { size: Math.round(14 * globalScaleFactor) },
                        automargin: true, fixedrange: true, categoryorder: 'array', categoryarray: metricNames
                    },
                    paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
                    legend: { orientation: "h", yanchor: "bottom", y: 1.02, xanchor: "left", x: 0, font: { size: Math.round(14 * globalScaleFactor) } },
                    margin: { l: 40, r: 25, b: 75, t: 35, pad: 5 },
                    annotations: [],
                    width: 285,
                    bargap: 0.4,
                    bargroupgap: 0.1
                }
            };
            return fig;
        }

        function populateInfoBoxes(patientInfo) {
            document.getElementById('p1-name').textContent = patientInfo.name || 'N/A';
            document.getElementById('p1-date').textContent = patientInfo.date || 'N/A';
            document.getElementById('p1-sport').textContent = patientInfo.sportPosition || 'N/A';
            document.getElementById('p1-createdBy').textContent = patientInfo.createdBy || 'N/A';

            document.getElementById('p2-name').textContent = patientInfo.name || 'N/A';
            document.getElementById('p2-date').textContent = patientInfo.date || 'N/A';
            document.getElementById('p2-sport').textContent = patientInfo.sportPosition || 'N/A';
            document.getElementById('p2-createdBy').textContent = patientInfo.createdBy || 'N/A';

            document.getElementById('p3-name').textContent = patientInfo.name || 'N/A';
            document.getElementById('p3-date').textContent = patientInfo.date || 'N/A';
            document.getElementById('p3-sport').textContent = patientInfo.sportPosition || 'N/A';
            document.getElementById('p3-createdBy').textContent = patientInfo.createdBy || 'N/A';
        }

        function updateManualTextBoxes(manualData) {
            // Defensive check: if manualData is null/undefined, create a default structure
            if (!manualData) {
                manualData = {};
            }
            // Ensure all sub-objects exist
            manualData.srp = manualData.srp || { tare: 0, force: 0 };
            manualData.spts = manualData.spts || { kg: 0 };
            manualData.mpu = manualData.mpu || { tare: 0, force: 0 };
            manualData.bpc = manualData.bpc || { hits: 0 };

            const srpContent = document.getElementById('manual-srp');
            if (manualData.srp.force === 0 && manualData.srp.tare === 0) {
                srpContent.innerHTML = `<div class="no-data-placeholder"><i class="fas fa-tasks"></i><p>Test ej genomfört</p></div>`;
            } else {
                const srpResult = manualData.srp.force - manualData.srp.tare;
                srpContent.innerHTML = `
                    <p><b>Tare:</b> ${manualData.srp.tare}N (Detta visar din ursprungsvikt i Newton på plattan)</p>
                    <p><b>Force:</b> ${manualData.srp.force}N (Detta visar din kraftutveckling)</p>
                    <p>= <b>${srpResult.toFixed(0)}N</b> i Kraftutveckling</p>`;
            }

            const sptsContent = document.getElementById('manual-spts');
            if (manualData.spts.kg === 0) {
                sptsContent.innerHTML = `<div class="no-data-placeholder"><i class="fas fa-tasks"></i><p>Test ej genomfört</p></div>`;
            } else {
                sptsContent.innerHTML = `
                    <p>Vi testade på vilken vikt du kunde bibehålla din <b>explosivitet</b> i knäböj kring <b>0,85m/s</b> (mellan <b>POWER og SPEED</b>) under 12 repetitioner, 3 set.</p>
                    <p>= <b>${manualData.spts.kg}kg</b></p>`;
            }

            const mpuContent = document.getElementById('manual-mpu');
            if (manualData.mpu.force === 0 && manualData.mpu.tare === 0) {
                mpuContent.innerHTML = `<div class="no-data-placeholder"><i class="fas fa-tasks"></i><p>Test ej genomfört</p></div>`;
            } else {
                const mpuResult = manualData.mpu.force - manualData.mpu.tare;
                mpuContent.innerHTML = `
                    <p><b>Tare:</b> ${manualData.mpu.tare}N (Detta visar din överkropps ursprungsvikt i Newton på plattan)</p>
                    <p><b>Force:</b> ${manualData.mpu.force}N (Detta visar din kraftutveckling)</p>
                    <p>= <b>${mpuResult.toFixed(0)}N</b> i Kraftutveckling</p>`;
            }

            const bpcContent = document.getElementById('manual-bpc');
            if (manualData.bpc.hits === 0) {
                bpcContent.innerHTML = `<div class="no-data-placeholder"><i class="fas fa-tasks"></i><p>Test ej genomfört</p></div>`;
            } else {
                bpcContent.innerHTML = `
                    <p>Plankstående 30s <b>reaktionsförmåga</b>, <b>max antal nudd</b></p>
                    <p>= <b>${manualData.bpc.hits}st</b></p>`;
            }
        }

        function showNoDataPlaceholder(plotDivId, message = "Test ej genomfört") {
            const plotDiv = document.getElementById(plotDivId);
            if (plotDiv) {
                Plotly.purge(plotDiv);
                plotDiv.innerHTML = `
                    <div class="no-data-placeholder">
                        <i class="fas fa-chart-line"></i>
                        <p>${message}</p>
                    </div>
                `;
            }
        }

        function populateCommentsAndDifferences(reportData) {
            function updateBox(boxId, comment, asymmetryPercent, hasData) {
                const box = document.getElementById(boxId);
                if (!box) return;

                const commentEl = box.querySelector('.comment-text');
                if (!commentEl) return;

                if (!hasData) {
                    commentEl.innerHTML = `<p style="color: var(--medium-gray); font-style: italic;">Ingen data för denna testen.</p>`;
                    return;
                }

                let contentHTML = '';
                if (asymmetryPercent !== undefined && !isNaN(asymmetryPercent)) {
                    const colorClass = asymmetryPercent <= -10 ? 'red' : 'green';
                    contentHTML += `<span class="percentage-display ${colorClass}">Asymmetri: ${asymmetryPercent.toFixed(1)}%.</span> `;
                }

                contentHTML += (comment || 'Ingen kommentar.');
                commentEl.innerHTML = contentHTML;
            }

            // Page 1
            const balanceData = reportData.page1.balance;
            const hasBalanceData = balanceData && !(balanceData.leftScore === 0 && balanceData.rightScore === 0 && balanceData.leftDiff === 0 && balanceData.rightDiff === 0);
            updateBox('p1-balance-comment-box', balanceData?.comment, balanceData?.asymmetryPercent, hasBalanceData);

            const cmjData = reportData.page1.cmj;
            const hasCmjData = cmjData && !(cmjData.vaJumps.every(j => j === 0) && cmjData.hoJumps.every(j => j === 0));
            updateBox('p1-cmj-comment-box', cmjData?.comment, cmjData?.asymmetryPercent, hasCmjData);

            const tiaData = reportData.page1.tia;
            const hasTiaData = tiaData && !(tiaData.leftJump === 0 && tiaData.rightJump === 0 && tiaData.leftGct === 0 && tiaData.rightGct === 0);
            updateBox('p1-tia-comment-box', tiaData?.comment, tiaData?.asymmetryPercent, hasTiaData);

            const sidehopData = reportData.page1.sidehop;
            const hasSidehopData = sidehopData && !(sidehopData.leftCount === 0 && sidehopData.rightCount === 0);
            updateBox('p1-sidehop-comment-box', sidehopData?.comment, sidehopData?.asymmetryPercent, hasSidehopData);

            const squatData = reportData.page1.squatAnalytics;
            const hasSquatData = squatData && !(squatData.attempt1 === 0 && squatData.attempt2 === 0 && squatData.attempt3 === 0);
            updateBox('p1-squat-comment-box', squatData?.comment, undefined, hasSquatData); // No asymmetry

            const repeatedData = reportData.page1.repeatedBilateral;
            const hasRepeatedData = repeatedData && !(repeatedData.avgHeight === 0 && repeatedData.avgGct === 0);
            updateBox('p1-repeated-comment-box', repeatedData?.comment, undefined, hasRepeatedData); // No asymmetry

            const cmj2benData = reportData.page1.cmj2ben;
            const hasCmj2benData = cmj2benData && !(cmj2benData.attempt1 === 0 && cmj2benData.attempt2 === 0 && cmj2benData.attempt3 === 0);
            updateBox('p1-cmj2ben-comment-box', cmj2benData?.comment, undefined, hasCmj2benData);

            // Page 2
            const hipThrustData = reportData.page2.strengthTests.hipThrust;
            const hasHipThrustData = hipThrustData && !(hipThrustData.left === 0 && hipThrustData.right === 0);
            updateBox('p2-hipthrust-comment-box', hipThrustData?.comment, hipThrustData?.asymmetryPercent, hasHipThrustData);

            const quadsData = reportData.page2.strengthTests.quadriceps;
            const hasQuadsData = quadsData && !(quadsData.left === 0 && quadsData.right === 0);
            updateBox('p2-quads-comment-box', quadsData?.comment, quadsData?.asymmetryPercent, hasQuadsData);

            const staticsquatHanddragData = reportData.page2.strengthTests.staticsquatHanddrag;
            const hasStaticsquatHanddragData = staticsquatHanddragData && !(staticsquatHanddragData.left === 0 && staticsquatHanddragData.right === 0 && staticsquatHanddragData.both === 0);
            updateBox('p2-staticsquat-handdrag-comment-box', staticsquatHanddragData?.comment, staticsquatHanddragData?.asymmetryPercent, hasStaticsquatHanddragData);

            const staticsquatHoftremData = reportData.page2.strengthTests.staticsquatHoftrem;
            const hasStaticsquatHoftremData = staticsquatHoftremData && !(staticsquatHoftremData.left === 0 && staticsquatHoftremData.right === 0 && staticsquatHoftremData.both === 0);
            updateBox('p2-staticsquat-hoftrem-comment-box', staticsquatHoftremData?.comment, staticsquatHoftremData?.asymmetryPercent, hasStaticsquatHoftremData);

            const hamstringData = reportData.page2.strengthTests.hamstring;
            const hasHamstringData = hamstringData && !(hamstringData.left === 0 && hamstringData.right === 0);
            updateBox('p2-hamstring-comment-box', hamstringData?.comment, hamstringData?.asymmetryPercent, hasHamstringData);

            const nordicHamstringData = reportData.page2.strengthTests.nordicHamstring;
            const hasNordicHamstringData = nordicHamstringData && !(nordicHamstringData.attempt1 === 0 && nordicHamstringData.attempt2 === 0 && nordicHamstringData.attempt3 === 0);
            updateBox('p2-nordic-hamstring-comment-box', nordicHamstringData?.comment, undefined, hasNordicHamstringData);
        }

        async function updateLayoutAndRenderGraphs(reportData) {
            const plotPromises = [];
            const templates = document.getElementById('templates');
            const typeCounts = {};

            // Helper to get data based on type and count (matching index.js logic)
            function getTestData(type, count) {
                const isFirst = count === 1;

                // Key Logic
                let key = type;
                if (type === 'repeated_bilateral') key = 'repeatedBilateral';
                if (type === 'cmj2ben') key = 'cmj2ben';
                if (type === 'squat') key = 'squatAnalytics';

                let p2key = type;
                if (type === 'hipthrust') p2key = 'hipThrust';
                if (type === 'quads') p2key = 'quadriceps';
                if (type === 'staticsquat-handdrag') p2key = 'staticsquatHanddrag';
                if (type === 'staticsquat-hoftrem') p2key = 'staticsquatHoftrem';
                if (type === 'nordic-hamstring') p2key = 'nordicHamstring';

                let finalKey = key;
                if (!isFirst) finalKey += `_${count - 1}`;

                let finalP2Key = p2key;
                if (!isFirst) finalP2Key += `_${count - 1}`;

                // Data Retrieval
                if (type === 'manual') {
                    // Manual logic in index.js seems to nest under page2.manual
                    // BUT collectDataFromForm says: data.page2.manual[finalP2Key] 
                    // AND manual entries like srp/spts are NOT arrays, they are properties of manual object.
                    // Actually, manual tests (srp, spts etc) are unique in the form? 
                    // No, the manual section is just one block. 
                    // IF there are multiple manual blocks... the index.js logic:
                    // if (type === 'manual') { data.page2.manual[finalP2Key] = ... }
                    // So we look in reportData.page2.manual
                    if (!reportData.page2.manual) return null;
                    if (isFirst) return reportData.page2.manual; // The whole manual object? 
                    // Wait, manual entries like 'srp' are keys INSIDE page2.manual.
                    // If multiple Manual sections existed, they would overwrite or merge?
                    // The Manual section in index.js is unique (id="test-section-manual").
                    // It doesn't seem to support duplicates in the same way?
                    // Let's assume manual is singleton for now or follows the key pattern if expanded.
                    // For now, let's treat manual as a special case or just return specific sub-parts.
                    // The report handles manual separately at the end of the static list usually.
                    // Let's stick to the other dynamic tests first.
                    return null;
                }

                // Page 2 Tests
                if (['hipthrust', 'quads', 'staticsquat-handdrag', 'staticsquat-hoftrem', 'hamstring', 'nordic-hamstring'].includes(type)) {
                    const container = reportData.page2.strengthTests;
                    if (!container) return null;
                    if (isFirst) return container[p2key];
                    return container[finalP2Key];
                }

                // Page 1 Tests
                const container = reportData.page1;
                if (!container) return null;
                return container[finalKey];
            }

            // Define Renderers
            const renderers = {
                'balance': {
                    templateId: 'col-balance',
                    checkData: (d) => d && !(d.leftScore === 0 && d.rightScore === 0 && d.leftDiff === 0 && d.rightDiff === 0),
                    render: (element, data, uniqueId) => {
                        element.querySelector('.position-title').textContent = 'STÅENDE BALANS 15S - UTAN RÖRELSE';
                        const fig = createDualAxisBarChart({ leftVal1: data.leftScore, rightVal1: data.rightScore, leftVal2: data.leftDiff, rightVal2: data.rightDiff }, { metricNames: ['Score', 'Gj. diff'], y1Title: 'Score', y2Title: 'cm', y1Decimals: 0, y2Decimals: 2 });
                        plotPromises.push(Plotly.react(element.querySelector('.js-plotly-plot'), fig.data, fig.layout, plotlyConfig));
                        // Update comment box? The static one had ID. Now we need to find it relative to element or update the clone's children.
                        // The template has .comment-text inside .explanation-box-small
                        const commentBox = element.querySelector('.comment-text');
                        if (commentBox) updateBoxContent(commentBox, data.comment, data.asymmetryPercent, true);
                    }
                },
                'cmj': {
                    templateId: 'col-cmj',
                    checkData: (d) => d && !(d.vaJumps.every(j => j === 0) && d.hoJumps.every(j => j === 0)),
                    render: (element, data, uniqueId) => {
                        element.querySelector('.normative-title').textContent = 'MAX HOPP CMJ (TOV)';
                        const fig = createGroupedBarChart({ labels: ['Hopp 1', 'Hopp 2', 'Hopp 3'], vaValues: data.vaJumps, hoValues: data.hoJumps }, { yTitle: 'Hopphøyde (cm)' });
                        plotPromises.push(Plotly.react(element.querySelector('.js-plotly-plot'), fig.data, fig.layout, plotlyConfig));
                        const commentBox = element.querySelector('.comment-text');
                        if (commentBox) updateBoxContent(commentBox, data.comment, data.asymmetryPercent, true);
                    }
                },
                'tia': {
                    templateId: 'col-tia',
                    checkData: (d) => d && !(d.leftJump === 0 && d.rightJump === 0 && d.leftGct === 0 && d.rightGct === 0),
                    render: (element, data, uniqueId) => {
                        element.querySelector('.position-title').textContent = 'REPETERADE HOPP (TIA) ETT BEN I TAGET';
                        const fig = createDualAxisBarChart({ leftVal1: data.leftJump, rightVal1: data.rightJump, leftVal2: data.leftGct, rightVal2: data.rightGct }, { metricNames: ['Gj. hopp', 'GCT'], y1Title: 'cm', y2Title: 's', y1Decimals: 1, y2Decimals: 2 });
                        plotPromises.push(Plotly.react(element.querySelector('.js-plotly-plot'), fig.data, fig.layout, plotlyConfig));
                        const commentBox = element.querySelector('.comment-text');
                        if (commentBox) updateBoxContent(commentBox, data.comment, data.asymmetryPercent, true);
                    }
                },
                'sidehop': {
                    templateId: 'col-sidehop',
                    checkData: (d) => d && !(d.leftCount === 0 && d.rightCount === 0),
                    render: (element, data, uniqueId) => {
                        element.querySelector('.normative-title').textContent = 'SIDOHOPP (TIA) 1 FÖRSÖK PER BEN, ANTAL';
                        const fig = createSingleMetricBarChart({ leftVal: data.leftCount, rightVal: data.rightCount }, { yAxisTitle: 'Antall (stk)', metricName: 'Antall', decimals: 0 });
                        plotPromises.push(Plotly.react(element.querySelector('.js-plotly-plot'), fig.data, fig.layout, plotlyConfig));
                        const commentBox = element.querySelector('.comment-text');
                        if (commentBox) updateBoxContent(commentBox, data.comment, data.asymmetryPercent, true);
                    }
                },
                'squat': {
                    templateId: 'col-squat',
                    checkData: (d) => d && !(d.attempt1 === 0 && d.attempt2 === 0 && d.attempt3 === 0),
                    render: (element, data, uniqueId) => {
                        element.querySelector('.position-title').textContent = 'Squat Analytics';
                        const donutValues = [data.attempt1, data.attempt2, data.attempt3];
                        const donutDivs = element.querySelectorAll('.js-plotly-plot');
                        donutValues.forEach((value, index) => {
                            // Fix IDs for plot
                            donutDivs[index].id = `donut-chart-${uniqueId}-${index}`;
                            const fig = createSingleDonutChart(value);
                            plotPromises.push(Plotly.newPlot(donutDivs[index], fig.data, fig.layout, plotlyConfig));
                        });
                        const commentBox = element.querySelector('.comment-text');
                        if (commentBox) updateBoxContent(commentBox, data.comment, undefined, true);
                    }
                },
                'repeated_bilateral': {
                    templateId: 'col-repeated',
                    checkData: (d) => d && !(d.avgHeight === 0 && d.avgGct === 0),
                    render: (element, data, uniqueId) => {
                        element.querySelector('.normative-title').textContent = 'REPETERADE HOPP (TIA) TVÅ BEN';
                        const fig = createBilateralDualAxisChart({ val1: data.avgHeight, val2: data.avgGct }, { metricNames: ['Gj. hopp', 'Gj. GCT'], y1Title: 'cm', y2Title: 's' });
                        plotPromises.push(Plotly.react(element.querySelector('.js-plotly-plot'), fig.data, fig.layout, plotlyConfig));
                        const commentBox = element.querySelector('.comment-text');
                        if (commentBox) updateBoxContent(commentBox, data.comment, undefined, true);
                    }
                },
                'cmj2ben': {
                    templateId: 'col-cmj2ben',
                    checkData: (d) => d && !(d.attempt1 === 0 && d.attempt2 === 0 && d.attempt3 === 0),
                    render: (element, data, uniqueId) => {
                        element.querySelector('.position-title').textContent = 'CMJ (TOV) TVÅ BEN';
                        const donutValues = [data.attempt1, data.attempt2, data.attempt3];
                        const donutDivs = element.querySelectorAll('.js-plotly-plot');
                        donutValues.forEach((value, index) => {
                            donutDivs[index].id = `cmj2ben-donut-${uniqueId}-${index}`;
                            const fig = createSingleDonutChart(value);
                            plotPromises.push(Plotly.newPlot(donutDivs[index], fig.data, fig.layout, plotlyConfig));
                        });
                        const commentBox = element.querySelector('.comment-text');
                        if (commentBox) updateBoxContent(commentBox, data.comment, undefined, true);
                    }
                },
                'hipthrust': {
                    templateId: 'col-hipthrust',
                    checkData: (d) => d && !(d.left === 0 && d.right === 0),
                    render: (element, data, uniqueId) => {
                        element.querySelector('.position-title').textContent = 'HIP THRUSTERS PULL';
                        const fig = createPage2CustomBarChart({ leftVal1: data.left, rightVal1: data.right }, { yAxisTitle: 'KG', metricNames: ['Force', ' '], decimals: 1 });
                        plotPromises.push(Plotly.react(element.querySelector('.js-plotly-plot'), fig.data, fig.layout, plotlyConfig));

                        // Animal Overlay unique IDs
                        const img = element.querySelector('.graph-overlay-image');
                        const txt = element.querySelector('.graph-overlay-text');
                        img.id = `overlay-image-${uniqueId}`;
                        txt.id = `overlay-text-${uniqueId}`;

                        if (data.tva && data.tva > 0) {
                            updateAnimalOverlay(data.tva, img, txt);
                        } else {
                            img.style.display = 'none';
                            txt.style.display = 'none';
                        }
                        const commentBox = element.querySelector('.comment-text');
                        if (commentBox) updateBoxContent(commentBox, data.comment, data.asymmetryPercent, true);
                    }
                },
                'quads': {
                    templateId: 'col-quads',
                    checkData: (d) => d && !(d.left === 0 && d.right === 0),
                    render: (element, data, uniqueId) => {
                        element.querySelector('.normative-title').textContent = 'QUADRICEPS ISOMETRISK STYRKA';
                        const fig = createPage2CustomBarChart({ leftVal1: data.left, rightVal1: data.right }, { yAxisTitle: 'KG', metricNames: ['Force', ' '], decimals: 1 });
                        plotPromises.push(Plotly.react(element.querySelector('.js-plotly-plot'), fig.data, fig.layout, plotlyConfig));
                        const commentBox = element.querySelector('.comment-text');
                        if (commentBox) updateBoxContent(commentBox, data.comment, data.asymmetryPercent, true);
                    }
                },
                'staticsquat-handdrag': {
                    templateId: 'col-staticsquat-handdrag',
                    checkData: (d) => d && !(d.left === 0 && d.right === 0 && d.both === 0),
                    render: (element, data, uniqueId) => {
                        element.querySelector('.position-title').textContent = 'STATIC SQUAT PULL - HANDDRAG';
                        const fig = createPage2CustomBarChart({ leftVal1: data.left, rightVal1: data.right }, { yAxisTitle: 'KG', metricNames: ['Force', ' '], decimals: 1 });
                        plotPromises.push(Plotly.react(element.querySelector('.js-plotly-plot'), fig.data, fig.layout, plotlyConfig));

                        const img = element.querySelector('.graph-overlay-image');
                        const txt = element.querySelector('.graph-overlay-text');
                        img.id = `overlay-image-handdrag-${uniqueId}`;
                        txt.id = `overlay-text-handdrag-${uniqueId}`;

                        if (data.both && data.both > 0) {
                            updateAnimalOverlay(data.both, img, txt);
                        } else {
                            img.style.display = 'none';
                            txt.style.display = 'none';
                        }
                        const commentBox = element.querySelector('.comment-text');
                        if (commentBox) updateBoxContent(commentBox, data.comment, data.asymmetryPercent, true);
                    }
                },
                'staticsquat-hoftrem': {
                    templateId: 'col-staticsquat-hoftrem',
                    checkData: (d) => d && !(d.left === 0 && d.right === 0 && d.both === 0),
                    render: (element, data, uniqueId) => {
                        element.querySelector('.position-title').textContent = 'STATIC SQUAT PULL - HÖFTREM';
                        const fig = createPage2CustomBarChart({ leftVal1: data.left, rightVal1: data.right }, { yAxisTitle: 'KG', metricNames: ['Force', ' '], decimals: 1 });
                        plotPromises.push(Plotly.react(element.querySelector('.js-plotly-plot'), fig.data, fig.layout, plotlyConfig));

                        const img = element.querySelector('.graph-overlay-image');
                        const txt = element.querySelector('.graph-overlay-text');
                        img.id = `overlay-image-hoftrem-${uniqueId}`;
                        txt.id = `overlay-text-hoftrem-${uniqueId}`;

                        if (data.both && data.both > 0) {
                            updateAnimalOverlay(data.both, img, txt);
                        } else {
                            img.style.display = 'none';
                            txt.style.display = 'none';
                        }
                        const commentBox = element.querySelector('.comment-text');
                        if (commentBox) updateBoxContent(commentBox, data.comment, data.asymmetryPercent, true);
                    }
                },
                'hamstring': {
                    templateId: 'col-hamstring',
                    checkData: (d) => d && !(d.left === 0 && d.right === 0),
                    render: (element, data, uniqueId) => {
                        element.querySelector('.normative-title').textContent = 'HAMSTRING ISOMETRISK STYRKA';
                        const fig = createPage2CustomBarChart({ leftVal1: data.left, rightVal1: data.right }, { yAxisTitle: 'Newton', metricNames: ['Force', ' '], decimals: 1 });
                        plotPromises.push(Plotly.react(element.querySelector('.js-plotly-plot'), fig.data, fig.layout, plotlyConfig));
                        const commentBox = element.querySelector('.comment-text');
                        if (commentBox) updateBoxContent(commentBox, data.comment, data.asymmetryPercent, true);
                    }
                },
                'nordic-hamstring': {
                    templateId: 'col-nordic-hamstring',
                    checkData: (d) => d && !(d.attempt1 === 0 && d.attempt2 === 0 && d.attempt3 === 0),
                    render: (element, data, uniqueId) => {
                        element.querySelector('.position-title').textContent = 'NORDIC HAMSTRINGS (TVÅ BEN)';
                        const donutValues = [data.attempt1, data.attempt2, data.attempt3];
                        const donutDivs = element.querySelectorAll('.js-plotly-plot');
                        donutValues.forEach((value, index) => {
                            donutDivs[index].id = `nordic-donut-${uniqueId}-${index}`;
                            const fig = createSingleDonutChart(value);
                            plotPromises.push(Plotly.newPlot(donutDivs[index], fig.data, fig.layout, plotlyConfig));
                        });
                        const commentBox = element.querySelector('.comment-text');
                        if (commentBox) updateBoxContent(commentBox, data.comment, undefined, true);
                    }
                }
            };

            // Re-implement updateBox for local elements
            function updateBoxContent(commentEl, comment, asymmetryPercent, hasData) {
                if (!hasData) {
                    commentEl.innerHTML = `<p style="color: var(--medium-gray); font-style: italic;">Ingen data för denna testen.</p>`;
                    return;
                }
                let contentHTML = '';
                if (asymmetryPercent !== undefined && !isNaN(asymmetryPercent)) {
                    const colorClass = asymmetryPercent <= -10 ? 'red' : 'green';
                    contentHTML += `<span class="percentage-display ${colorClass}">Asymmetri: ${asymmetryPercent.toFixed(1)}%.</span> `;
                }
                contentHTML += (comment || 'Ingen kommentar.');
                commentEl.innerHTML = contentHTML;
            }

            // PROCESSING LOOP

            // Containers
            const page1Container = document.getElementById('report-content-page1');
            const page2Container = document.getElementById('report-content-page2');
            const page3Container = document.getElementById('report-content-page3');

            let currentContainer = page1Container;
            let currentRow = null;
            let renderedCount = 0;

            // 1. Process Dynamic Tests from activeTestIds
            let testIdsToProcess = reportData.activeTestIds || [];

            // Fallback for old data without activeTestIds: try to deduce from all test types
            if (testIdsToProcess.length === 0) {
                // Define a standard order if checking manually
                // This is just a fallback for backward compatibility
                const standardOrder = ['balance', 'cmj', 'tia', 'sidehop', 'squat', 'repeated_bilateral', 'cmj2ben',
                    'hipthrust', 'quads', 'staticsquat-handdrag', 'staticsquat-hoftrem', 'hamstring', 'nordic-hamstring'];

                standardOrder.forEach(type => {
                    // Check if data exists for at least one
                    // This is tricky without counts. We'll just assume 1 instance per type for fallback.
                    const data = getTestData(type, 1);
                    if (data) testIdsToProcess.push(type);
                });
            }

            // Helper for Custom Graphs
            function renderCustomGraph(element, data, uniqueId) {
                const graphType = data.graphType || 'unknown';
                const title = data.title || 'Custom Test';
                const config = data.config || {};

                // Set Title
                const titleEl = element.querySelector('.position-title');
                if (titleEl) titleEl.textContent = title.toUpperCase();

                const plotDiv = element.querySelector('.js-plotly-plot');

                // Manual Test Special Case
                if (graphType === 'manual') {
                    if (plotDiv) plotDiv.style.display = 'none';

                    const container = element.querySelector('.position-box');
                    if (container) {
                        // Remove existing text-content if any
                        const existing = container.querySelector('.text-content');
                        if (existing) existing.remove();

                        const contentDiv = document.createElement('div');
                        contentDiv.className = 'text-content';
                        contentDiv.style.padding = '10px';
                        contentDiv.style.fontSize = '0.9em';

                        let html = '';
                        const vals = data.manualValues || [];
                        const labels = config.metricNames || [];

                        vals.forEach((val, i) => {
                            const label = labels[i] || `Label ${i + 1}`;
                            if (val) html += `<p style="margin: 4px 0;"><b>${label}:</b> ${val}</p>`;
                        });

                        if (!html) html = '<p class="no-data-placeholder">Ingen data</p>';
                        contentDiv.innerHTML = html;
                        container.appendChild(contentDiv);
                    }
                    return; // No plot to render
                }

                if (!plotDiv) return;

                // Chart Logic
                let fig;
                const metricNames = config.metricNames || ['Value 1', 'Value 2'];
                const yAxisTitle = config.yAxisTitle || 'Värde';
                const decimals = config.decimals !== undefined ? config.decimals : 1;

                switch (graphType) {
                    case 'dual-axis':
                        fig = createDualAxisBarChart({
                            leftVal1: data.val1_L || 0, rightVal1: data.val1_R || 0,
                            leftVal2: data.val2_L || 0, rightVal2: data.val2_R || 0
                        }, {
                            metricNames: metricNames,
                            y1Title: config.y1Title || yAxisTitle,
                            y2Title: config.y2Title || 'Tid (ms)',
                            y1Decimals: decimals,
                            y2Decimals: config.decimals2 || 2
                        });
                        break;
                    case 'grouped-bar-3':
                        fig = createGroupedBarChart({
                            labels: metricNames,
                            vaValues: [data.g1_L || 0, data.g2_L || 0, data.g3_L || 0],
                            hoValues: [data.g1_R || 0, data.g2_R || 0, data.g3_R || 0]
                        }, { yTitle: yAxisTitle });
                        break;
                    case 'three-bar':
                        fig = createThreeBarChart({
                            leftVal: data.val_L || 0, rightVal: data.val_R || 0, bothVal: data.val_Both || 0
                        }, { yAxisTitle: yAxisTitle, decimals: decimals });
                        break;
                    case 'single-bar':
                    case 'paired-bar':
                        fig = createSingleMetricBarChart({
                            leftVal: data.left || 0, rightVal: data.right || 0
                        }, { yAxisTitle: yAxisTitle, metricName: metricNames[0], decimals: decimals });
                        break;
                    case 'bilateral':
                        fig = createBilateralDualAxisChart({
                            val1: data.val1 || 0, val2: data.val2 || 0
                        }, { metricNames: metricNames, y1Title: metricNames[0], y2Title: metricNames[1] });
                        break;
                    case 'donut':
                    case 'single-bars-3':
                        // Map to 3-bar for now as placeholder
                        fig = createThreeBarChart({
                            leftVal: data.val1 || 0, rightVal: data.val2 || 0, bothVal: data.val3 || 0
                        }, { yAxisTitle: yAxisTitle, decimals: decimals });
                        break;
                }

                if (fig) {
                    Plotly.react(plotDiv, fig.data, fig.layout, plotlyConfig);
                }

                // Comments
                const commentBox = element.querySelector('.comment-text');
                if (commentBox) updateBoxContent(commentBox, data.comment, data.asymmetryPercent, true);
            }

            testIdsToProcess.forEach(type => {
                if (type === 'manual') return; // Handled separately

                let renderer = renderers[type];
                let isCustom = false;
                let data = null;
                let count = 0;

                // Handle Custom Tests
                if (!renderer && type.startsWith('custom_')) {
                    isCustom = true;
                    // For custom tests, count remains 0 or can be 1 if needed for tracking, 
                    // but we won't use it for data fetching or uniqueId construction the same way.

                    renderer = {
                        templateId: 'col-custom',
                        checkData: (d) => {
                            if (!d || !d.active) return false;

                            // Manual Tests
                            if (d.graphType === 'manual' && d.manualValues) {
                                return d.manualValues.some(v => v && v.trim() !== '');
                            }

                            // Numeric Tests (Any value > 0)
                            const vals = Object.values(d).filter(v => typeof v === 'number');
                            if (vals.length > 0) return vals.some(v => v > 0);

                            return false;
                        },
                        render: (element, d, uid) => renderCustomGraph(element, d, uid)
                    };

                    const customId = type.replace('custom_', '');
                    if (reportData.page2.custom) {
                        data = reportData.page2.custom[customId];
                    }
                } else {
                    // Standard Logic
                    typeCounts[type] = (typeCounts[type] || 0) + 1;
                    count = typeCounts[type];
                    if (renderer) data = getTestData(type, count);
                }

                if (!renderer) return;

                const hasData = isCustom ? renderer.checkData(data) : renderer.checkData(data);

                if (hasData) {
                    const uniqueId = isCustom ? type : `${type}_${count}`;
                    const template = templates.querySelector(`#${renderer.templateId}`);
                    if (!template) return;

                    const clone = template.cloneNode(true);
                    clone.id = `col-${uniqueId}`; // Unique column ID

                    // Assign Unique ID to Plotly Div
                    const plotDiv = clone.querySelector('.js-plotly-plot');
                    if (plotDiv) plotDiv.id = `plot-${uniqueId}`;

                    // Place in Row
                    if (renderedCount % 2 === 0) {
                        // Determine page based on pair count
                        // 0-5 pairs (0-11 items) -> Page 1 & 2? 
                        // Existing logic:
                        // Index < 6 (0-5) -> Page 1 (3 rows, 6 items)
                        // Index < 12 (6-11) -> Page 2 (3 rows, 6 items)
                        // Index >= 12 -> Page 3

                        // Wait, previous logic was:
                        // index < 6 -> page1 (items 0,1,2,3,4,5)
                        // index >= 6 -> page2 (items 6,7,8,9,10,11)
                        // index >= 12 -> page3

                        if (renderedCount >= 12) currentContainer = page3Container;
                        else if (renderedCount >= 6) currentContainer = page2Container;
                        else currentContainer = page1Container;

                        currentRow = document.createElement('div');
                        currentRow.className = 'position-row';
                        currentContainer.appendChild(currentRow);
                    }

                    currentRow.appendChild(clone);
                    renderer.render(clone, data, uniqueId);
                    renderedCount++;
                }
            });

            // 2. Process Manual Tests (Append to end)
            // Manual blocks are still static in formatting usually, but let's check legacy manual flags
            const manualBlocks = [
                { id: 'srp', colId: 'col-srp', check: (d) => d && d.srp && !(d.srp.force === 0 && d.srp.tare === 0) },
                { id: 'spts', colId: 'col-spts', check: (d) => d && d.spts && d.spts.kg !== 0 },
                { id: 'mpu', colId: 'col-mpu', check: (d) => d && d.mpu && !(d.mpu.force === 0 && d.mpu.tare === 0) },
                { id: 'bpc', colId: 'col-bpc', check: (d) => d && d.bpc && d.bpc.hits !== 0 }
            ];

            const manualData = reportData.page2.manual;

            manualBlocks.forEach(block => {
                if (block.check(manualData)) {
                    const template = templates.querySelector(`#${block.colId}`);
                    if (!template) return;
                    const clone = template.cloneNode(true);
                    clone.id = `manual-${block.id}-clone`;

                    // Text content is already populated by updateManualTextBoxes?
                    // No, updateManualTextBoxes targets IDs like 'manual-srp'.
                    // The clone will have duplicate IDs inside. We must fix or update content here.
                    // The text-content div has ID like "manual-srp".
                    const contentDiv = clone.querySelector('.text-content');
                    if (contentDiv) {
                        const origId = contentDiv.id; // e.g. manual-srp
                        contentDiv.id = `${origId}-clone`;
                        // Manually populate it since updateManualTextBoxes ran on the hidden template?
                        // Actually updateManualTextBoxes likely ran on the templates already if they were reachable?
                        // No, templates is hidden. updateManualTextBoxes probably tried to update elements by ID.
                        // But if they are in #templates, they are hidden.
                        // Let's copy the content from the logic or re-run logic.

                        let text = '';
                        if (block.id === 'srp') text = `Avlastad kraft: <b>${manualData.srp.tare} N</b><br>Max kraft: <b>${manualData.srp.force} N</b>`;
                        if (block.id === 'spts') text = `Vikt: <b>${manualData.spts.kg} kg</b>`;
                        if (block.id === 'mpu') text = `Avlastad kraft: <b>${manualData.mpu.tare} N</b><br>Max kraft: <b>${manualData.mpu.force} N</b>`;
                        if (block.id === 'bpc') text = `Antal träffar: <b>${manualData.bpc.hits}</b>`;

                        contentDiv.innerHTML = text;
                    }

                    if (renderedCount % 2 === 0) {
                        if (renderedCount >= 12) currentContainer = page3Container;
                        else if (renderedCount >= 6) currentContainer = page2Container;
                        else currentContainer = page1Container;

                        currentRow = document.createElement('div');
                        currentRow.className = 'position-row';
                        currentContainer.appendChild(currentRow);
                    }
                    currentRow.appendChild(clone);
                    renderedCount++;
                }
            });


            // Pages Visibility Logic
            const page1 = document.getElementById('page-1');
            const page2 = document.getElementById('page-2');
            const page3 = document.getElementById('page-3');

            page1.classList.remove('page-break');
            page2.classList.remove('page-break');
            page2.classList.add('hidden');
            page3.classList.add('hidden');

            if (renderedCount > 12) {
                page1.classList.add('page-break');
                page2.classList.remove('hidden');
                page2.classList.add('page-break');
                page3.classList.remove('hidden');
            } else if (renderedCount > 6) {
                page1.classList.add('page-break');
                page2.classList.remove('hidden');
            }

            await Promise.all(plotPromises);

            setTimeout(() => {
                const allPlotDivs = document.querySelectorAll('.js-plotly-plot');
                allPlotDivs.forEach(gd => {
                    if (gd && typeof gd.layout !== 'undefined') {
                        try { Plotly.Plots.resize(gd); } catch (e) { console.warn("Error resizing plot:", gd.id, e); }
                    }
                });
                // Auto-print enabled as per user request
                setTimeout(() => window.print(), 500);
            }, 150);
        }

        window.addEventListener('load', () => {
            scaleHtmlFontSizes(globalScaleFactor);

            const storedData = localStorage.getItem('fysiosportData');

            if (storedData) {
                try {
                    const reportData = JSON.parse(storedData);
                    populateInfoBoxes(reportData.patientInfo);
                    updateManualTextBoxes(reportData.page2.manual);
                    populateCommentsAndDifferences(reportData);
                    updateLayoutAndRenderGraphs(reportData);
                } catch (e) {
                    console.error("Failed to parse or render data from localStorage:", e);
                }
            } else {
                console.warn("No data found in localStorage. Cannot generate report.");
            }
        });

        window.addEventListener('resize', () => {
            const allDivs = document.querySelectorAll('.js-plotly-plot');
            allDivs.forEach(gd => {
                if (gd && typeof gd.layout !== 'undefined') {
                    try { Plotly.Plots.resize(gd); } catch (e) { /* Ignore */ }
                }
            });
        }, 150); 
    </script>
</body>

</html>